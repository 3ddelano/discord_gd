# Represents a Discord message
class_name Message extends DiscordDataclass

var id: String # Id of the message
var channel_id: String # Id of the channel the message was sent in
var author: User # The author of this message (not guaranteed to be a valid user)
var content: String # Contents of the message
var timestamp: String # When this message was sent
var edited_timestamp = null # [String] When this message was edited (or null if never) `nullable`
var tts: bool # Whether this was a TTS message
var mention_everyone: bool # Whether this message mentions everyone
var mentions: Array # [Array] of [User] Users specifically mentioned in the message
var mention_roles: Array # [Array] of [String] Roles Ids of roles specifically mentioned in this message
var mention_channels = null # [Array] of [ChannelMention] Channels specifically mentioned in this message `optional`
var attachments: Array # [Array] of [Attachment] Any attached files
var embeds: Array # [Array] of [Embed] Any embedded content
var reactions = null # [Array] of [Reaction] Reactions to the message `optional`
var nonce = null # [int] | [String] Used for validating a message was sent `optional`
var pinned: bool # Whether this message is pinned
var webhook_id = null # [String] If the message is generated by a webhook, this is the webhook's id `optional`
var type: int # [MessageTypes] type of message
var activity = null # [MessageActivity] Sent with Rich Presence-related chat embeds `optional`
var application = null # Partial [Application] Sent with Rich Presence-related chat embeds `optional`
var application_id = null # [String] If the message is an [Interaction] or application-owned webhook, this is the id of the application `optional`
var message_reference = null # [MessageReference] Data showing the source of a crosspost, channel follow add, pin, or reply message `optional`
var flags = null # [MessageFlags] Message flags combined as a bitfield `optional`
var referenced_message = null # [Message] The message associated with the message_reference `optional` `nullable`
var interaction = null # [MessageInteraction] Sent if the message is a response to an [Interaction] `optional`
var thread = null # [Channel] The thread that was started from this message, includes [ThreadMember] `optional`
var components = null # [Array] of [MessageActionRow] Sent if the message contains components like buttons, action rows, or other interactive components `optional`
var sticker_items = null # [Array] of [MessageStickerItem] Sent if the message contains stickers `optional`
var stickers = null # [Array] of Sticker (deprecated) The stickers sent with the message `optional`


# @hidden
func _init().("Message"): return self


# @hidden
func from_dict(p_dict: Dictionary):
	.from_dict(p_dict)

	author = User.new().from_dict(p_dict.author)
	if p_dict.has("mentions"):
		mentions = []
		for data in p_dict.mentions:
			mentions.append(User.new().from_dict(data))
	if p_dict.has("mention_channels"):
		mention_channels = []
		for data in p_dict.mention_channels:
			mention_channels.append(ChannelMention.new().from_dict(data))
	if p_dict.has("attachments"):
		attachments = []
		for data in p_dict.attachments:
			attachments.append(Attachment.new().from_dict(data))
	if p_dict.has("embeds"):
		embeds = []
		for data in p_dict.embeds:
			embeds.append(Embed.new().from_dict(data))
	if p_dict.has("reactions"):
		reactions = []
		for data in p_dict.reactions:
			reactions.append(Reaction.new().from_dict(data))
	if p_dict.has("activity"):
		activity = MessageActivity.new().from_dict(p_dict.activity)
	if p_dict.has("application"):
		application = Application.new().from_dict(p_dict.application)
	if p_dict.has("message_reference"):
		message_reference = MessageReference.new().from_dict(p_dict.message_reference)
	if p_dict.has("flags"):
		flags = MessageFlags.new(p_dict.flags)
	if p_dict.has("referenced_message") and p_dict.referenced_message != null:
		referenced_message = get_script().new().from_dict(p_dict.referenced_message) # TODO: check if get_script() works
	if p_dict.has("interaction"):
		interaction = MessageInteraction.new().from_dict(p_dict.interaction)
	if p_dict.has("thread"):
		thread = Channel.new().from_dict(p_dict.thread)
	if p_dict.has("components"):
		components = []
		for data in p_dict.components:
			components.append(MessageActionRow.new().from_dict(data))
	if p_dict.has("sticker_items"):
		sticker_items = []
		for data in p_dict.sticker_items:
			sticker_items.append(StickerItem.new().from_dict(data))
	if p_dict.has("stickers"):
		stickers = []
		for data in p_dict.stickers:
			stickers.append(Sticker.new().from_dict(data))
	return self


# @hidden
func to_dict() -> Dictionary:
	var dict = .to_dict()

	DiscordUtils.try_dataclass_to_dict(dict, "author")
	DiscordUtils.try_dataclass_to_dict(dict, "activity")
	DiscordUtils.try_dataclass_to_dict(dict, "application")
	DiscordUtils.try_dataclass_to_dict(dict, "message_reference")
	DiscordUtils.try_dataclass_to_dict(dict, "flags")
	DiscordUtils.try_dataclass_to_dict(dict, "referenced_message")
	DiscordUtils.try_dataclass_to_dict(dict, "interaction")
	DiscordUtils.try_dataclass_to_dict(dict, "thread")
	DiscordUtils.try_array_dataclass_to_dict(dict, "mentions")
	DiscordUtils.try_array_dataclass_to_dict(dict, "mention_channels")
	DiscordUtils.try_array_dataclass_to_dict(dict, "attachments")
	DiscordUtils.try_array_dataclass_to_dict(dict, "embeds")
	DiscordUtils.try_array_dataclass_to_dict(dict, "reactions")
	DiscordUtils.try_array_dataclass_to_dict(dict, "components")
	DiscordUtils.try_array_dataclass_to_dict(dict, "sticker_items")
	DiscordUtils.try_array_dataclass_to_dict(dict, "stickers")

	return dict
